From 21da76d1f1b527d62b2e9ef79dd9aa514d996341 Mon Sep 17 00:00:00 2001
From: opavlyuk <40970635+opavlyuk@users.noreply.github.com>
Date: Wed, 26 Feb 2020 16:33:57 +0200
Subject: [PATCH] bpo-34788: Add support for scoped IPv6 addresses (GH-13772)

Automerge-Triggered-By: @asvetlov
---
 Doc/library/ipaddress.rst                     |  26 +-
 Doc/library/socket.rst                        |  20 +-
 Doc/tools/susp-ignored.csv                    |   2 +
 Doc/whatsnew/3.9.rst                          |   9 +
 Lib/ipaddress.py                              |  55 ++-
 Lib/test/test_ipaddress.py                    | 467 +++++++++++++++++-
 .../2019-07-17-08-26-14.bpo-34788.pwV1OK.rst  |   2 +
 7 files changed, 544 insertions(+), 37 deletions(-)
 create mode 100644 Misc/NEWS.d/next/Library/2019-07-17-08-26-14.bpo-34788.pwV1OK.rst

--- python3.8-3.8.10.orig/Doc/library/ipaddress.rst
+++ python3.8-3.8.10/Doc/library/ipaddress.rst
@@ -252,11 +252,20 @@ write code that handles both IP versions
       :RFC:`4291` for details.  For example,
       ``"0000:0000:0000:0000:0000:0abc:0007:0def"`` can be compressed to
       ``"::abc:7:def"``.
+
+      Optionally, the string may also have a scope zone ID, expressed
+      with a suffix ``%scope_id``. If present, the scope ID must be non-empty,
+      and may not contain ``%``.
+      See :RFC:`4007` for details.
+      For example, ``fe80::1234%1`` might identify address ``fe80::1234`` on the first link of the node.
    2. An integer that fits into 128 bits.
    3. An integer packed into a :class:`bytes` object of length 16, big-endian.
 
+
    >>> ipaddress.IPv6Address('2001:db8::1000')
    IPv6Address('2001:db8::1000')
+   >>> ipaddress.IPv6Address('ff02::5678%1')
+   IPv6Address('ff02::5678%1')
 
    .. attribute:: compressed
 
@@ -303,6 +312,12 @@ write code that handles both IP versions
       ``::FFFF/96``), this property will report the embedded IPv4 address.
       For any other address, this property will be ``None``.
 
+   .. attribute:: scope_id
+
+      For scoped addresses as defined by :RFC:`4007`, this property identifies
+      the particular zone of the address's scope that the address belongs to,
+      as a string. When no scope zone is specified, this property will be ``None``.
+
    .. attribute:: sixtofour
 
       For addresses that appear to be 6to4 addresses  (starting with
@@ -334,6 +349,8 @@ the :func:`str` and :func:`int` builtin
    >>> int(ipaddress.IPv6Address('::1'))
    1
 
+Note that IPv6 scoped addresses are converted to integers without scope zone ID.
+
 
 Operators
 ^^^^^^^^^
@@ -346,8 +363,9 @@ IPv6).
 Comparison operators
 """"""""""""""""""""
 
-Address objects can be compared with the usual set of comparison operators.  Some
-examples::
+Address objects can be compared with the usual set of comparison operators.
+Same IPv6 addresses with different scope zone IDs are not equal.
+Some examples::
 
    >>> IPv4Address('127.0.0.2') > IPv4Address('127.0.0.1')
    True
@@ -355,6 +373,10 @@ examples::
    False
    >>> IPv4Address('127.0.0.2') != IPv4Address('127.0.0.1')
    True
+   >>> IPv6Address('fe80::1234') == IPv6Address('fe80::1234%1')
+   False
+   >>> IPv6Address('fe80::1234%1') != IPv6Address('fe80::1234%2')
+   True
 
 
 Arithmetic operators
--- python3.8-3.8.10.orig/Doc/library/socket.rst
+++ python3.8-3.8.10/Doc/library/socket.rst
@@ -78,15 +78,15 @@ created.  Socket addresses are represent
     Python programs.
 
 - For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo,
-  scopeid)`` is used, where *flowinfo* and *scopeid* represent the ``sin6_flowinfo``
+  scope_id)`` is used, where *flowinfo* and *scope_id* represent the ``sin6_flowinfo``
   and ``sin6_scope_id`` members in :const:`struct sockaddr_in6` in C.  For
-  :mod:`socket` module methods, *flowinfo* and *scopeid* can be omitted just for
-  backward compatibility.  Note, however, omission of *scopeid* can cause problems
+  :mod:`socket` module methods, *flowinfo* and *scope_id* can be omitted just for
+  backward compatibility.  Note, however, omission of *scope_id* can cause problems
   in manipulating scoped IPv6 addresses.
 
   .. versionchanged:: 3.7
-     For multicast addresses (with *scopeid* meaningful) *address* may not contain
-     ``%scope`` (or ``zone id``) part. This information is superfluous and may
+     For multicast addresses (with *scope_id* meaningful) *address* may not contain
+     ``%scope_id`` (or ``zone id``) part. This information is superfluous and may
      be safely omitted (recommended).
 
 - :const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``.
@@ -721,7 +721,7 @@ The :mod:`socket` module also offers var
    :const:`AI_CANONNAME` is part of the *flags* argument; else *canonname*
    will be empty.  *sockaddr* is a tuple describing a socket address, whose
    format depends on the returned *family* (a ``(address, port)`` 2-tuple for
-   :const:`AF_INET`, a ``(address, port, flow info, scope id)`` 4-tuple for
+   :const:`AF_INET`, a ``(address, port, flowinfo, scope_id)`` 4-tuple for
    :const:`AF_INET6`), and is meant to be passed to the :meth:`socket.connect`
    method.
 
@@ -742,7 +742,7 @@ The :mod:`socket` module also offers var
 
    .. versionchanged:: 3.7
       for IPv6 multicast addresses, string representing an address will not
-      contain ``%scope`` part.
+      contain ``%scope_id`` part.
 
 .. function:: getfqdn([name])
 
@@ -810,8 +810,8 @@ The :mod:`socket` module also offers var
    or numeric address representation in *host*.  Similarly, *port* can contain a
    string port name or a numeric port number.
 
-   For IPv6 addresses, ``%scope`` is appended to the host part if *sockaddr*
-   contains meaningful *scopeid*. Usually this happens for multicast addresses.
+   For IPv6 addresses, ``%scope_id`` is appended to the host part if *sockaddr*
+   contains meaningful *scope_id*. Usually this happens for multicast addresses.
 
    For more information about *flags* you can consult :manpage:`getnameinfo(3)`.
 
@@ -1356,7 +1356,7 @@ to sockets.
 
    .. versionchanged:: 3.7
       For multicast IPv6 address, first item of *address* does not contain
-      ``%scope`` part anymore. In order to get full IPv6 address use
+      ``%scope_id`` part anymore. In order to get full IPv6 address use
       :func:`getnameinfo`.
 
 .. method:: socket.recvmsg(bufsize[, ancbufsize[, flags]])
--- python3.8-3.8.10.orig/Doc/tools/susp-ignored.csv
+++ python3.8-3.8.10/Doc/tools/susp-ignored.csv
@@ -144,6 +144,8 @@ library/ipaddress,,:db8,>>> ipaddress.IP
 library/ipaddress,,::,>>> ipaddress.IPv6Address('2001:db8::1000')
 library/ipaddress,,:db8,IPv6Address('2001:db8::1000')
 library/ipaddress,,::,IPv6Address('2001:db8::1000')
+library/ipaddress,,::,IPv6Address('ff02::5678%1')
+library/ipaddress,,::,fe80::1234
 library/ipaddress,,:db8,">>> ipaddress.ip_address(""2001:db8::1"").reverse_pointer"
 library/ipaddress,,::,">>> ipaddress.ip_address(""2001:db8::1"").reverse_pointer"
 library/ipaddress,,::,"""::abc:7:def"""
--- python3.8-3.8.10.orig/Lib/ipaddress.py
+++ python3.8-3.8.10/Lib/ipaddress.py
@@ -1822,6 +1822,26 @@ class _BaseV6:
         reverse_chars = self.exploded[::-1].replace(':', '')
         return '.'.join(reverse_chars) + '.ip6.arpa'
 
+    @staticmethod
+    def _split_scope_id(ip_str):
+        """Helper function to parse IPv6 string address with scope id.
+
+        See RFC 4007 for details.
+
+        Args:
+            ip_str: A string, the IPv6 address.
+
+        Returns:
+            (addr, scope_id) tuple.
+
+        """
+        addr, sep, scope_id = ip_str.partition('%')
+        if not sep:
+            scope_id = None
+        elif not scope_id or '%' in scope_id:
+            raise AddressValueError('Invalid IPv6 address: "%r"' % ip_str)
+        return addr, scope_id
+
     @property
     def max_prefixlen(self):
         return self._max_prefixlen
@@ -1835,7 +1855,7 @@ class IPv6Address(_BaseV6, _BaseAddress)
 
     """Represent and manipulate single IPv6 Addresses."""
 
-    __slots__ = ('_ip', '__weakref__')
+    __slots__ = ('_ip', '_scope_id', '__weakref__')
 
     def __init__(self, address):
         """Instantiate a new IPv6 address object.
@@ -1858,12 +1878,14 @@ class IPv6Address(_BaseV6, _BaseAddress)
         if isinstance(address, int):
             self._check_int_address(address)
             self._ip = address
+            self._scope_id = None
             return
 
         # Constructing from a packed address
         if isinstance(address, bytes):
             self._check_packed_address(address, 16)
             self._ip = int.from_bytes(address, 'big')
+            self._scope_id = None
             return
 
         # Assume input argument to be string or any object representation
@@ -1871,8 +1893,37 @@ class IPv6Address(_BaseV6, _BaseAddress)
         addr_str = str(address)
         if '/' in addr_str:
             raise AddressValueError("Unexpected '/' in %r" % address)
+        addr_str, self._scope_id = self._split_scope_id(addr_str)
+
         self._ip = self._ip_int_from_string(addr_str)
 
+    def __str__(self):
+        ip_str = super().__str__()
+        return ip_str + '%' + self._scope_id if self._scope_id else ip_str
+
+    def __hash__(self):
+        return hash((self._ip, self._scope_id))
+
+    def __eq__(self, other):
+        address_equal = super().__eq__(other)
+        if address_equal is NotImplemented:
+            return NotImplemented
+        if not address_equal:
+            return False
+        return self._scope_id == getattr(other, '_scope_id', None)
+
+    @property
+    def scope_id(self):
+        """Identifier of a particular zone of the address's scope.
+
+        See RFC 4007 for details.
+
+        Returns:
+            A string identifying the zone of the address if specified, else None.
+
+        """
+        return self._scope_id
+
     @property
     def packed(self):
         """The binary representation of this address."""
@@ -2045,7 +2096,7 @@ class IPv6Interface(IPv6Address):
         return self.network.hostmask
 
     def __str__(self):
-        return '%s/%d' % (self._string_from_ip_int(self._ip),
+        return '%s/%d' % (super().__str__(),
                           self._prefixlen)
 
     def __eq__(self, other):
--- python3.8-3.8.10.orig/Lib/test/test_ipaddress.py
+++ python3.8-3.8.10/Lib/test/test_ipaddress.py
@@ -183,6 +183,15 @@ class CommonTestMixin_v6(CommonTestMixin
         assertBadLength(15)
         assertBadLength(17)
 
+    def test_blank_scope_id(self):
+        address = ('::1%')
+        with self.assertAddressError('Invalid IPv6 address: "%r"', address):
+            self.factory(address)
+
+    def test_invalid_scope_id_with_percent(self):
+        address = ('::1%scope%')
+        with self.assertAddressError('Invalid IPv6 address: "%r"', address):
+            self.factory(address)
 
 class AddressTestCase_v4(BaseTestCase, CommonTestMixin_v4):
     factory = ipaddress.IPv4Address
@@ -275,24 +284,30 @@ class AddressTestCase_v6(BaseTestCase, C
     factory = ipaddress.IPv6Address
 
     def test_network_passed_as_address(self):
-        addr = "::1/24"
-        with self.assertAddressError("Unexpected '/' in %r", addr):
-            ipaddress.IPv6Address(addr)
+        def assertBadSplit(addr):
+            msg = "Unexpected '/' in %r"
+            with self.assertAddressError(msg, addr):
+                ipaddress.IPv6Address(addr)
+        assertBadSplit("::1/24")
+        assertBadSplit("::1%scope_id/24")
 
     def test_bad_address_split_v6_not_enough_parts(self):
         def assertBadSplit(addr):
             msg = "At least 3 parts expected in %r"
-            with self.assertAddressError(msg, addr):
+            with self.assertAddressError(msg, addr.split('%')[0]):
                 ipaddress.IPv6Address(addr)
 
         assertBadSplit(":")
         assertBadSplit(":1")
         assertBadSplit("FEDC:9878")
+        assertBadSplit(":%scope")
+        assertBadSplit(":1%scope")
+        assertBadSplit("FEDC:9878%scope")
 
     def test_bad_address_split_v6_too_many_colons(self):
         def assertBadSplit(addr):
             msg = "At most 8 colons permitted in %r"
-            with self.assertAddressError(msg, addr):
+            with self.assertAddressError(msg, addr.split('%')[0]):
                 ipaddress.IPv6Address(addr)
 
         assertBadSplit("9:8:7:6:5:4:3::2:1")
@@ -302,10 +317,17 @@ class AddressTestCase_v6(BaseTestCase, C
         # A trailing IPv4 address is two parts
         assertBadSplit("10:9:8:7:6:5:4:3:42.42.42.42")
 
+        assertBadSplit("9:8:7:6:5:4:3::2:1%scope")
+        assertBadSplit("10:9:8:7:6:5:4:3:2:1%scope")
+        assertBadSplit("::8:7:6:5:4:3:2:1%scope")
+        assertBadSplit("8:7:6:5:4:3:2:1::%scope")
+        # A trailing IPv4 address is two parts
+        assertBadSplit("10:9:8:7:6:5:4:3:42.42.42.42%scope")
+
     def test_bad_address_split_v6_too_many_parts(self):
         def assertBadSplit(addr):
             msg = "Exactly 8 parts expected without '::' in %r"
-            with self.assertAddressError(msg, addr):
+            with self.assertAddressError(msg, addr.split('%')[0]):
                 ipaddress.IPv6Address(addr)
 
         assertBadSplit("3ffe:0:0:0:0:0:0:0:1")
@@ -315,18 +337,26 @@ class AddressTestCase_v6(BaseTestCase, C
         assertBadSplit("9:8:7:6:5:4:3:42.42.42.42")
         assertBadSplit("7:6:5:4:3:42.42.42.42")
 
+        assertBadSplit("3ffe:0:0:0:0:0:0:0:1%scope")
+        assertBadSplit("9:8:7:6:5:4:3:2:1%scope")
+        assertBadSplit("7:6:5:4:3:2:1%scope")
+        # A trailing IPv4 address is two parts
+        assertBadSplit("9:8:7:6:5:4:3:42.42.42.42%scope")
+        assertBadSplit("7:6:5:4:3:42.42.42.42%scope")
+
     def test_bad_address_split_v6_too_many_parts_with_double_colon(self):
         def assertBadSplit(addr):
             msg = "Expected at most 7 other parts with '::' in %r"
-            with self.assertAddressError(msg, addr):
+            with self.assertAddressError(msg, addr.split('%')[0]):
                 ipaddress.IPv6Address(addr)
 
         assertBadSplit("1:2:3:4::5:6:7:8")
+        assertBadSplit("1:2:3:4::5:6:7:8%scope")
 
     def test_bad_address_split_v6_repeated_double_colon(self):
         def assertBadSplit(addr):
             msg = "At most one '::' permitted in %r"
-            with self.assertAddressError(msg, addr):
+            with self.assertAddressError(msg, addr.split('%')[0]):
                 ipaddress.IPv6Address(addr)
 
         assertBadSplit("3ffe::1::1")
@@ -340,10 +370,21 @@ class AddressTestCase_v6(BaseTestCase, C
         assertBadSplit(":::")
         assertBadSplit('2001:db8:::1')
 
+        assertBadSplit("3ffe::1::1%scope")
+        assertBadSplit("1::2::3::4:5%scope")
+        assertBadSplit("2001::db:::1%scope")
+        assertBadSplit("3ffe::1::%scope")
+        assertBadSplit("::3ffe::1%scope")
+        assertBadSplit(":3ffe::1::1%scope")
+        assertBadSplit("3ffe::1::1:%scope")
+        assertBadSplit(":3ffe::1::1:%scope")
+        assertBadSplit(":::%scope")
+        assertBadSplit('2001:db8:::1%scope')
+
     def test_bad_address_split_v6_leading_colon(self):
         def assertBadSplit(addr):
             msg = "Leading ':' only permitted as part of '::' in %r"
-            with self.assertAddressError(msg, addr):
+            with self.assertAddressError(msg, addr.split('%')[0]):
                 ipaddress.IPv6Address(addr)
 
         assertBadSplit(":2001:db8::1")
@@ -351,10 +392,15 @@ class AddressTestCase_v6(BaseTestCase, C
         assertBadSplit(":1:2:3:4:5:6:")
         assertBadSplit(":6:5:4:3:2:1::")
 
+        assertBadSplit(":2001:db8::1%scope")
+        assertBadSplit(":1:2:3:4:5:6:7%scope")
+        assertBadSplit(":1:2:3:4:5:6:%scope")
+        assertBadSplit(":6:5:4:3:2:1::%scope")
+
     def test_bad_address_split_v6_trailing_colon(self):
         def assertBadSplit(addr):
             msg = "Trailing ':' only permitted as part of '::' in %r"
-            with self.assertAddressError(msg, addr):
+            with self.assertAddressError(msg, addr.split('%')[0]):
                 ipaddress.IPv6Address(addr)
 
         assertBadSplit("2001:db8::1:")
@@ -362,9 +408,14 @@ class AddressTestCase_v6(BaseTestCase, C
         assertBadSplit("::1.2.3.4:")
         assertBadSplit("::7:6:5:4:3:2:")
 
+        assertBadSplit("2001:db8::1:%scope")
+        assertBadSplit("1:2:3:4:5:6:7:%scope")
+        assertBadSplit("::1.2.3.4:%scope")
+        assertBadSplit("::7:6:5:4:3:2:%scope")
+
     def test_bad_v4_part_in(self):
         def assertBadAddressPart(addr, v4_error):
-            with self.assertAddressError("%s in %r", v4_error, addr):
+            with self.assertAddressError("%s in %r", v4_error, addr.split('%')[0]):
                 ipaddress.IPv6Address(addr)
 
         assertBadAddressPart("3ffe::1.net", "Expected 4 octets in '1.net'")
@@ -378,9 +429,20 @@ class AddressTestCase_v6(BaseTestCase, C
                              "Only decimal digits permitted in 'net' "
                              "in '1.1.1.net'")
 
+        assertBadAddressPart("3ffe::1.net%scope", "Expected 4 octets in '1.net'")
+        assertBadAddressPart("3ffe::127.0.1%scope",
+                             "Expected 4 octets in '127.0.1'")
+        assertBadAddressPart("::1.2.3%scope",
+                             "Expected 4 octets in '1.2.3'")
+        assertBadAddressPart("::1.2.3.4.5%scope",
+                             "Expected 4 octets in '1.2.3.4.5'")
+        assertBadAddressPart("3ffe::1.1.1.net%scope",
+                             "Only decimal digits permitted in 'net' "
+                             "in '1.1.1.net'")
+
     def test_invalid_characters(self):
         def assertBadPart(addr, part):
-            msg = "Only hex digits permitted in %r in %r" % (part, addr)
+            msg = "Only hex digits permitted in %r in %r" % (part, addr.split('%')[0])
             with self.assertAddressError(re.escape(msg)):
                 ipaddress.IPv6Address(addr)
 
@@ -391,10 +453,17 @@ class AddressTestCase_v6(BaseTestCase, C
         assertBadPart("1.2.3.4::", "1.2.3.4")
         assertBadPart('1234:axy::b', "axy")
 
+        assertBadPart("3ffe::goog%scope", "goog")
+        assertBadPart("3ffe::-0%scope", "-0")
+        assertBadPart("3ffe::+0%scope", "+0")
+        assertBadPart("3ffe::-1%scope", "-1")
+        assertBadPart("1.2.3.4::%scope", "1.2.3.4")
+        assertBadPart('1234:axy::b%scope', "axy")
+
     def test_part_length(self):
         def assertBadPart(addr, part):
             msg = "At most 4 characters permitted in %r in %r"
-            with self.assertAddressError(msg, part, addr):
+            with self.assertAddressError(msg, part, addr.split('%')[0]):
                 ipaddress.IPv6Address(addr)
 
         assertBadPart("::00000", "00000")
@@ -402,11 +471,17 @@ class AddressTestCase_v6(BaseTestCase, C
         assertBadPart("02001:db8::", "02001")
         assertBadPart('2001:888888::1', "888888")
 
+        assertBadPart("::00000%scope", "00000")
+        assertBadPart("3ffe::10000%scope", "10000")
+        assertBadPart("02001:db8::%scope", "02001")
+        assertBadPart('2001:888888::1%scope', "888888")
+
     def test_pickle(self):
         self.pickle_test('2001:db8::')
 
     def test_weakref(self):
         weakref.ref(self.factory('2001:db8::'))
+        weakref.ref(self.factory('2001:db8::%scope'))
 
 
 class NetmaskTestMixin_v4(CommonTestMixin_v4):
@@ -564,11 +639,20 @@ class NetmaskTestMixin_v6(CommonTestMixi
             # IPv6Network has prefixlen, but IPv6Interface doesn't.
             # Should we add it to IPv4Interface too? (bpo-36392)
 
+        scoped_net = self.factory('::1%scope')
+        self.assertEqual(str(scoped_net), '::1%scope/128')
+        self.assertEqual(str(scoped_net.netmask), 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff')
+        self.assertEqual(str(scoped_net.hostmask), '::')
+
     def test_split_netmask(self):
         addr = "cafe:cafe::/128/190"
         with self.assertAddressError("Only one '/' permitted in %r" % addr):
             self.factory(addr)
 
+        scoped_addr = "cafe:cafe::%scope/128/190"
+        with self.assertAddressError("Only one '/' permitted in %r" % scoped_addr):
+            self.factory(scoped_addr)
+
     def test_address_errors(self):
         def assertBadAddress(addr, details):
             with self.assertAddressError(details):
@@ -581,6 +665,13 @@ class NetmaskTestMixin_v6(CommonTestMixi
         assertBadAddress("10/8", "At least 3 parts")
         assertBadAddress("1234:axy::b", "Only hex digits")
 
+        assertBadAddress("/%scope", "Address cannot be empty")
+        assertBadAddress("/%scope8", "Address cannot be empty")
+        assertBadAddress("google.com%scope", "At least 3 parts")
+        assertBadAddress("1.2.3.4%scope", "At least 3 parts")
+        assertBadAddress("10%scope/8", "At least 3 parts")
+        assertBadAddress("1234:axy::b%scope", "Only hex digits")
+
     def test_valid_netmask(self):
         # We only support CIDR for IPv6, because expanded netmasks are not
         # standard notation.
@@ -592,6 +683,14 @@ class NetmaskTestMixin_v6(CommonTestMixi
             # Zero prefix is treated as decimal.
             self.assertEqual(str(self.factory('::/0%d' % i)), net_str)
 
+        self.assertEqual(str(self.factory('2001:db8::%scope/32')), '2001:db8::%scope/32')
+        for i in range(0, 129):
+            # Generate and re-parse the CIDR format (trivial).
+            net_str = '::/%d' % i
+            self.assertEqual(str(self.factory(net_str)), net_str)
+            # Zero prefix is treated as decimal.
+            self.assertEqual(str(self.factory('::/0%d' % i)), net_str)
+
     def test_netmask_errors(self):
         def assertBadNetmask(addr, netmask):
             msg = "%r is not a valid netmask" % netmask
@@ -610,6 +709,8 @@ class NetmaskTestMixin_v6(CommonTestMixi
         assertBadNetmask("::1", "pudding")
         assertBadNetmask("::", "::")
 
+        assertBadNetmask("::1%scope", "pudding")
+
     def test_netmask_in_tuple_errors(self):
         def assertBadNetmask(addr, netmask):
             msg = "%r is not a valid netmask" % netmask
@@ -617,12 +718,15 @@ class NetmaskTestMixin_v6(CommonTestMixi
                 self.factory((addr, netmask))
         assertBadNetmask("::1", -1)
         assertBadNetmask("::1", 129)
+        assertBadNetmask("::1%scope", 129)
 
     def test_pickle(self):
         self.pickle_test('2001:db8::1000/124')
         self.pickle_test('2001:db8::1000/127')  # IPV6LENGTH - 1
         self.pickle_test('2001:db8::1000')      # IPV6LENGTH
 
+        self.pickle_test('2001:db8::1000%scope')      # IPV6LENGTH
+
 
 class InterfaceTestCase_v6(BaseTestCase, NetmaskTestMixin_v6):
     factory = ipaddress.IPv6Interface
@@ -649,6 +753,13 @@ class NetworkTestCase_v6(BaseTestCase, N
             self.factory('2000:aaa::/48').subnet_of(
                 self.factory('2000:aaa::/56')))
 
+        self.assertFalse(
+            self.factory('2000:999::%scope/56').subnet_of(
+                self.factory('2000:aaa::%scope/48')))
+        self.assertTrue(
+            self.factory('2000:aaa::%scope/56').subnet_of(
+                self.factory('2000:aaa::%scope/48')))
+
     def test_supernet_of(self):
         # containee left of container
         self.assertFalse(
@@ -695,13 +806,19 @@ class ComparisonTests(unittest.TestCase)
     v6addr = ipaddress.IPv6Address(1)
     v6net = ipaddress.IPv6Network(1)
     v6intf = ipaddress.IPv6Interface(1)
+    v6addr_scoped = ipaddress.IPv6Address('::1%scope')
+    v6net_scoped= ipaddress.IPv6Network('::1%scope')
+    v6intf_scoped= ipaddress.IPv6Interface('::1%scope')
 
     v4_addresses = [v4addr, v4intf]
     v4_objects = v4_addresses + [v4net]
     v6_addresses = [v6addr, v6intf]
     v6_objects = v6_addresses + [v6net]
+    v6_scoped_addresses = [v6addr_scoped, v6intf_scoped]
+    v6_scoped_objects = v6_scoped_addresses + [v6net_scoped]
 
     objects = v4_objects + v6_objects
+    objects_with_scoped = objects + v6_scoped_objects
 
     v4addr2 = ipaddress.IPv4Address(2)
     v4net2 = ipaddress.IPv4Network(2)
@@ -709,11 +826,14 @@ class ComparisonTests(unittest.TestCase)
     v6addr2 = ipaddress.IPv6Address(2)
     v6net2 = ipaddress.IPv6Network(2)
     v6intf2 = ipaddress.IPv6Interface(2)
+    v6addr2_scoped = ipaddress.IPv6Address('::2%scope')
+    v6net2_scoped = ipaddress.IPv6Network('::2%scope')
+    v6intf2_scoped = ipaddress.IPv6Interface('::2%scope')
 
     def test_foreign_type_equality(self):
         # __eq__ should never raise TypeError directly
         other = object()
-        for obj in self.objects:
+        for obj in self.objects_with_scoped:
             self.assertNotEqual(obj, other)
             self.assertFalse(obj == other)
             self.assertEqual(obj.__eq__(other), NotImplemented)
@@ -728,8 +848,17 @@ class ComparisonTests(unittest.TestCase)
                     continue
                 self.assertNotEqual(lhs, rhs)
 
+    def test_scoped_ipv6_equality(self):
+        for lhs, rhs in zip(self.v6_objects, self.v6_scoped_objects):
+            self.assertNotEqual(lhs, rhs)
+
+    def test_v4_with_v6_scoped_equality(self):
+        for lhs in self.v4_objects:
+            for rhs in self.v6_scoped_objects:
+                self.assertNotEqual(lhs, rhs)
+
     def test_same_type_equality(self):
-        for obj in self.objects:
+        for obj in self.objects_with_scoped:
             self.assertEqual(obj, obj)
             self.assertLessEqual(obj, obj)
             self.assertGreaterEqual(obj, obj)
@@ -742,6 +871,9 @@ class ComparisonTests(unittest.TestCase)
             (self.v6addr, self.v6addr2),
             (self.v6net, self.v6net2),
             (self.v6intf, self.v6intf2),
+            (self.v6addr_scoped, self.v6addr2_scoped),
+            (self.v6net_scoped, self.v6net2_scoped),
+            (self.v6intf_scoped, self.v6intf2_scoped),
         ):
             self.assertNotEqual(lhs, rhs)
             self.assertLess(lhs, rhs)
@@ -756,16 +888,21 @@ class ComparisonTests(unittest.TestCase)
     def test_containment(self):
         for obj in self.v4_addresses:
             self.assertIn(obj, self.v4net)
-        for obj in self.v6_addresses:
+        for obj in self.v6_addresses + self.v6_scoped_addresses:
             self.assertIn(obj, self.v6net)
-        for obj in self.v4_objects + [self.v6net]:
+        for obj in self.v6_addresses + self.v6_scoped_addresses:
+            self.assertIn(obj, self.v6net_scoped)
+
+        for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
             self.assertNotIn(obj, self.v6net)
-        for obj in self.v6_objects + [self.v4net]:
+        for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
+            self.assertNotIn(obj, self.v6net_scoped)
+        for obj in self.v6_objects + self.v6_scoped_objects + [self.v4net]:
             self.assertNotIn(obj, self.v4net)
 
     def test_mixed_type_ordering(self):
-        for lhs in self.objects:
-            for rhs in self.objects:
+        for lhs in self.objects_with_scoped:
+            for rhs in self.objects_with_scoped:
                 if isinstance(lhs, type(rhs)) or isinstance(rhs, type(lhs)):
                     continue
                 self.assertRaises(TypeError, lambda: lhs < rhs)
@@ -775,7 +912,7 @@ class ComparisonTests(unittest.TestCase)
 
     def test_foreign_type_ordering(self):
         other = object()
-        for obj in self.objects:
+        for obj in self.objects_with_scoped:
             with self.assertRaises(TypeError):
                 obj < other
             with self.assertRaises(TypeError):
@@ -797,14 +934,18 @@ class ComparisonTests(unittest.TestCase)
         # with get_mixed_type_key, you can sort addresses and network.
         v4_ordered = [self.v4addr, self.v4net, self.v4intf]
         v6_ordered = [self.v6addr, self.v6net, self.v6intf]
+        v6_scoped_ordered = [self.v6addr_scoped, self.v6net_scoped, self.v6intf_scoped]
         self.assertEqual(v4_ordered,
                          sorted(self.v4_objects,
                                 key=ipaddress.get_mixed_type_key))
         self.assertEqual(v6_ordered,
                          sorted(self.v6_objects,
                                 key=ipaddress.get_mixed_type_key))
-        self.assertEqual(v4_ordered + v6_ordered,
-                         sorted(self.objects,
+        self.assertEqual(v6_scoped_ordered,
+                         sorted(self.v6_scoped_objects,
+                                key=ipaddress.get_mixed_type_key))
+        self.assertEqual(v4_ordered + v6_scoped_ordered,
+                         sorted(self.v4_objects + self.v6_scoped_objects,
                                 key=ipaddress.get_mixed_type_key))
         self.assertEqual(NotImplemented, ipaddress.get_mixed_type_key(object))
 
@@ -814,6 +955,8 @@ class ComparisonTests(unittest.TestCase)
         v4net = ipaddress.ip_network('1.1.1.1')
         v6addr = ipaddress.ip_address('::1')
         v6net = ipaddress.ip_network('::1')
+        v6addr_scoped = ipaddress.ip_address('::1%scope')
+        v6net_scoped = ipaddress.ip_network('::1%scope')
 
         self.assertRaises(TypeError, v4addr.__lt__, v6addr)
         self.assertRaises(TypeError, v4addr.__gt__, v6addr)
@@ -825,6 +968,16 @@ class ComparisonTests(unittest.TestCase)
         self.assertRaises(TypeError, v6net.__lt__, v4net)
         self.assertRaises(TypeError, v6net.__gt__, v4net)
 
+        self.assertRaises(TypeError, v4addr.__lt__, v6addr_scoped)
+        self.assertRaises(TypeError, v4addr.__gt__, v6addr_scoped)
+        self.assertRaises(TypeError, v4net.__lt__, v6net_scoped)
+        self.assertRaises(TypeError, v4net.__gt__, v6net_scoped)
+
+        self.assertRaises(TypeError, v6addr_scoped.__lt__, v4addr)
+        self.assertRaises(TypeError, v6addr_scoped.__gt__, v4addr)
+        self.assertRaises(TypeError, v6net_scoped.__lt__, v4net)
+        self.assertRaises(TypeError, v6net_scoped.__gt__, v4net)
+
 
 class IpaddrUnitTest(unittest.TestCase):
 
@@ -838,12 +991,19 @@ class IpaddrUnitTest(unittest.TestCase):
         self.ipv6_interface = ipaddress.IPv6Interface(
             '2001:658:22a:cafe:200:0:0:1/64')
         self.ipv6_network = ipaddress.IPv6Network('2001:658:22a:cafe::/64')
+        self.ipv6_scoped_address = ipaddress.IPv6Interface(
+            '2001:658:22a:cafe:200:0:0:1%scope')
+        self.ipv6_scoped_interface = ipaddress.IPv6Interface(
+            '2001:658:22a:cafe:200:0:0:1%scope/64')
+        self.ipv6_scoped_network = ipaddress.IPv6Network('2001:658:22a:cafe::%scope/64')
 
     def testRepr(self):
         self.assertEqual("IPv4Interface('1.2.3.4/32')",
                          repr(ipaddress.IPv4Interface('1.2.3.4')))
         self.assertEqual("IPv6Interface('::1/128')",
                          repr(ipaddress.IPv6Interface('::1')))
+        self.assertEqual("IPv6Interface('::1%scope/128')",
+                         repr(ipaddress.IPv6Interface('::1%scope')))
 
     # issue #16531: constructing IPv4Network from an (address, mask) tuple
     def testIPv4Tuple(self):
@@ -930,6 +1090,8 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertEqual(ipaddress.IPv6Network((ip, '96')),
                          net)
 
+        ip_scoped = ipaddress.IPv6Address('2001:db8::%scope')
+
         # strict=True and host bits set
         ip = ipaddress.IPv6Address('2001:db8::1')
         with self.assertRaises(ValueError):
@@ -958,6 +1120,13 @@ class IpaddrUnitTest(unittest.TestCase):
                 (42540766411282592856903984951653826561, '96')),
                          ipaddress.IPv6Interface('2001:db8::1/96'))
 
+        ip_scoped = ipaddress.IPv6Address('2001:db8::1%scope')
+        with self.assertRaises(ValueError):
+            ipaddress.IPv6Network(('2001:db8::1%scope', 96))
+        with self.assertRaises(ValueError):
+            ipaddress.IPv6Network((ip_scoped, 96))
+        # strict=False and host bits set
+
     # issue57
     def testAddressIntMath(self):
         self.assertEqual(ipaddress.IPv4Address('1.1.1.1') + 255,
@@ -968,6 +1137,10 @@ class IpaddrUnitTest(unittest.TestCase):
                          ipaddress.IPv6Address('::ffff'))
         self.assertEqual(ipaddress.IPv6Address('::ffff') - (2**16 - 2),
                          ipaddress.IPv6Address('::1'))
+        self.assertNotEqual(ipaddress.IPv6Address('::1%scope') + (2**16 - 2),
+                            ipaddress.IPv6Address('::ffff%scope'))
+        self.assertNotEqual(ipaddress.IPv6Address('::ffff%scope') - (2**16 - 2),
+                            ipaddress.IPv6Address('::1%scope'))
 
     def testInvalidIntToBytes(self):
         self.assertRaises(ValueError, ipaddress.v4_int_to_packed, -1)
@@ -1000,6 +1173,12 @@ class IpaddrUnitTest(unittest.TestCase):
                          '2001:658:22a:cafe::')
         self.assertEqual(str(self.ipv6_network.hostmask),
                          '::ffff:ffff:ffff:ffff')
+        self.assertEqual(int(self.ipv6_scoped_network.network_address),
+                         42540616829182469433403647294022090752)
+        self.assertEqual(str(self.ipv6_scoped_network.network_address),
+                         '2001:658:22a:cafe::%scope')
+        self.assertEqual(str(self.ipv6_scoped_network.hostmask),
+                         '::ffff:ffff:ffff:ffff')
 
     def testIpFromInt(self):
         self.assertEqual(self.ipv4_interface._ip,
@@ -1007,17 +1186,23 @@ class IpaddrUnitTest(unittest.TestCase):
 
         ipv4 = ipaddress.ip_network('1.2.3.4')
         ipv6 = ipaddress.ip_network('2001:658:22a:cafe:200:0:0:1')
+        ipv6_scoped = ipaddress.ip_network('2001:658:22a:cafe:200:0:0:1%scope')
         self.assertEqual(ipv4, ipaddress.ip_network(int(ipv4.network_address)))
         self.assertEqual(ipv6, ipaddress.ip_network(int(ipv6.network_address)))
+        self.assertNotEqual(ipv6_scoped, ipaddress.ip_network(int(ipv6_scoped.network_address)))
 
         v6_int = 42540616829182469433547762482097946625
         self.assertEqual(self.ipv6_interface._ip,
                          ipaddress.IPv6Interface(v6_int)._ip)
+        self.assertEqual(self.ipv6_scoped_interface._ip,
+                         ipaddress.IPv6Interface(v6_int)._ip)
 
         self.assertEqual(ipaddress.ip_network(self.ipv4_address._ip).version,
                          4)
         self.assertEqual(ipaddress.ip_network(self.ipv6_address._ip).version,
                          6)
+        self.assertEqual(ipaddress.ip_network(self.ipv6_scoped_address._ip).version,
+                         6)
 
     def testIpFromPacked(self):
         address = ipaddress.ip_address
@@ -1043,6 +1228,24 @@ class IpaddrUnitTest(unittest.TestCase):
                          42540616829182469433547762482097946625)
         self.assertEqual(str(self.ipv6_interface.ip),
                          '2001:658:22a:cafe:200::1')
+        self.assertEqual(int(self.ipv6_scoped_interface.ip),
+                         42540616829182469433547762482097946625)
+        self.assertEqual(str(self.ipv6_scoped_interface.ip),
+                         '2001:658:22a:cafe:200::1')
+
+    def testGetScopeId(self):
+        self.assertEqual(self.ipv6_address.scope_id,
+                         None)
+        self.assertEqual(str(self.ipv6_scoped_address.scope_id),
+                         'scope')
+        self.assertEqual(self.ipv6_interface.scope_id,
+                         None)
+        self.assertEqual(str(self.ipv6_scoped_interface.scope_id),
+                         'scope')
+        self.assertEqual(self.ipv6_network.network_address.scope_id,
+                         None)
+        self.assertEqual(str(self.ipv6_scoped_network.network_address.scope_id),
+                         'scope')
 
     def testGetNetmask(self):
         self.assertEqual(int(self.ipv4_network.netmask), 4294967040)
@@ -1050,6 +1253,9 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertEqual(int(self.ipv6_network.netmask),
                          340282366920938463444927863358058659840)
         self.assertEqual(self.ipv6_network.prefixlen, 64)
+        self.assertEqual(int(self.ipv6_scoped_network.netmask),
+                         340282366920938463444927863358058659840)
+        self.assertEqual(self.ipv6_scoped_network.prefixlen, 64)
 
     def testZeroNetmask(self):
         ipv4_zero_netmask = ipaddress.IPv4Interface('1.2.3.4/0')
@@ -1060,6 +1266,10 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertEqual(int(ipv6_zero_netmask.network.netmask), 0)
         self.assertEqual(ipv6_zero_netmask._prefix_from_prefix_string('0'), 0)
 
+        ipv6_scoped_zero_netmask = ipaddress.IPv6Interface('::1%scope/0')
+        self.assertEqual(int(ipv6_scoped_zero_netmask.network.netmask), 0)
+        self.assertEqual(ipv6_scoped_zero_netmask._prefix_from_prefix_string('0'), 0)
+
     def testIPv4Net(self):
         net = ipaddress.IPv4Network('127.0.0.0/0.0.0.255')
         self.assertEqual(net.prefixlen, 24)
@@ -1073,9 +1283,15 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertEqual(str(self.ipv6_network.broadcast_address),
                          '2001:658:22a:cafe:ffff:ffff:ffff:ffff')
 
+        self.assertEqual(int(self.ipv6_scoped_network.broadcast_address),
+                         42540616829182469451850391367731642367)
+        self.assertEqual(str(self.ipv6_scoped_network.broadcast_address),
+                         '2001:658:22a:cafe:ffff:ffff:ffff:ffff')
+
     def testGetPrefixlen(self):
         self.assertEqual(self.ipv4_interface.network.prefixlen, 24)
         self.assertEqual(self.ipv6_interface.network.prefixlen, 64)
+        self.assertEqual(self.ipv6_scoped_interface.network.prefixlen, 64)
 
     def testGetSupernet(self):
         self.assertEqual(self.ipv4_network.supernet().prefixlen, 23)
@@ -1090,6 +1306,9 @@ class IpaddrUnitTest(unittest.TestCase):
                          '2001:658:22a:cafe::')
         self.assertEqual(ipaddress.IPv6Interface('::0/0').network.supernet(),
                          ipaddress.IPv6Network('::0/0'))
+        self.assertEqual(self.ipv6_scoped_network.supernet().prefixlen, 63)
+        self.assertEqual(str(self.ipv6_scoped_network.supernet().network_address),
+                         '2001:658:22a:cafe::')
 
     def testGetSupernet3(self):
         self.assertEqual(self.ipv4_network.supernet(3).prefixlen, 21)
@@ -1099,6 +1318,9 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertEqual(self.ipv6_network.supernet(3).prefixlen, 61)
         self.assertEqual(str(self.ipv6_network.supernet(3).network_address),
                          '2001:658:22a:caf8::')
+        self.assertEqual(self.ipv6_scoped_network.supernet(3).prefixlen, 61)
+        self.assertEqual(str(self.ipv6_scoped_network.supernet(3).network_address),
+                         '2001:658:22a:caf8::')
 
     def testGetSupernet4(self):
         self.assertRaises(ValueError, self.ipv4_network.supernet,
@@ -1114,6 +1336,12 @@ class IpaddrUnitTest(unittest.TestCase):
                           new_prefix=65)
         self.assertEqual(self.ipv6_network.supernet(prefixlen_diff=2),
                          self.ipv6_network.supernet(new_prefix=62))
+        self.assertRaises(ValueError, self.ipv6_scoped_network.supernet,
+                          prefixlen_diff=2, new_prefix=1)
+        self.assertRaises(ValueError, self.ipv6_scoped_network.supernet,
+                          new_prefix=65)
+        self.assertEqual(self.ipv6_scoped_network.supernet(prefixlen_diff=2),
+                         self.ipv6_scoped_network.supernet(new_prefix=62))
 
     def testHosts(self):
         hosts = list(self.ipv4_network.hosts())
@@ -1127,6 +1355,12 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertEqual(ipaddress.IPv6Address('2001:658:22a:cafe::1'), hosts[0])
         self.assertEqual(ipaddress.IPv6Address('2001:658:22a:cafe::ff'), hosts[-1])
 
+        ipv6_scoped_network = ipaddress.IPv6Network('2001:658:22a:cafe::%scope/120')
+        hosts = list(ipv6_scoped_network.hosts())
+        self.assertEqual(255, len(hosts))
+        self.assertEqual(ipaddress.IPv6Address('2001:658:22a:cafe::1'), hosts[0])
+        self.assertEqual(ipaddress.IPv6Address('2001:658:22a:cafe::ff'), hosts[-1])
+
         # special case where only 1 bit is left for address
         addrs = [ipaddress.IPv4Address('2.0.0.0'),
                  ipaddress.IPv4Address('2.0.0.1')]
@@ -1162,6 +1396,14 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
         self.assertEqual(list(ipaddress.ip_network(str_args).hosts()),
                          list(ipaddress.ip_network(tpl_args).hosts()))
+        addrs = [ipaddress.IPv6Address('2001:658:22a:cafe::'),
+                 ipaddress.IPv6Address('2001:658:22a:cafe::1')]
+        str_args = '2001:658:22a:cafe::/127'
+        tpl_args = ('2001:658:22a:cafe::', 127)
+        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
+        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
+        self.assertEqual(list(ipaddress.ip_network(str_args).hosts()),
+                         list(ipaddress.ip_network(tpl_args).hosts()))
 
     def testFancySubnetting(self):
         self.assertEqual(sorted(self.ipv4_network.subnets(prefixlen_diff=3)),
@@ -1178,6 +1420,13 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertRaises(ValueError, list,
                           self.ipv6_network.subnets(prefixlen_diff=4,
                                                    new_prefix=68))
+        self.assertEqual(sorted(self.ipv6_scoped_network.subnets(prefixlen_diff=4)),
+                         sorted(self.ipv6_scoped_network.subnets(new_prefix=68)))
+        self.assertRaises(ValueError, list,
+                          self.ipv6_scoped_network.subnets(new_prefix=63))
+        self.assertRaises(ValueError, list,
+                          self.ipv6_scoped_network.subnets(prefixlen_diff=4,
+                                                           new_prefix=68))
 
     def testGetSubnets(self):
         self.assertEqual(list(self.ipv4_network.subnets())[0].prefixlen, 25)
@@ -1189,6 +1438,7 @@ class IpaddrUnitTest(unittest.TestCase):
                          '1.2.3.128')
 
         self.assertEqual(list(self.ipv6_network.subnets())[0].prefixlen, 65)
+        self.assertEqual(list(self.ipv6_scoped_network.subnets())[0].prefixlen, 65)
 
     def testGetSubnetForSingle32(self):
         ip = ipaddress.IPv4Network('1.2.3.4/32')
@@ -1204,6 +1454,12 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertEqual(subnets1, ['::1/128'])
         self.assertEqual(subnets1, subnets2)
 
+        ip_scoped = ipaddress.IPv6Network('::1%scope/128')
+        subnets1 = [str(x) for x in ip_scoped.subnets()]
+        subnets2 = [str(x) for x in ip_scoped.subnets(2)]
+        self.assertEqual(subnets1, ['::1%scope/128'])
+        self.assertEqual(subnets1, subnets2)
+
     def testSubnet2(self):
         ips = [str(x) for x in self.ipv4_network.subnets(2)]
         self.assertEqual(
@@ -1247,12 +1503,18 @@ class IpaddrUnitTest(unittest.TestCase):
                           self.ipv6_interface.network.subnets(65))
         self.assertRaises(ValueError, list,
                           self.ipv6_network.subnets(65))
+        self.assertRaises(ValueError, list,
+                          self.ipv6_scoped_interface.network.subnets(65))
+        self.assertRaises(ValueError, list,
+                          self.ipv6_scoped_network.subnets(65))
 
     def testSupernetFailsForLargeCidrDiff(self):
         self.assertRaises(ValueError,
                           self.ipv4_interface.network.supernet, 25)
         self.assertRaises(ValueError,
                           self.ipv6_interface.network.supernet, 65)
+        self.assertRaises(ValueError,
+                          self.ipv6_scoped_interface.network.supernet, 65)
 
     def testSubnetFailsForNegativeCidrDiff(self):
         self.assertRaises(ValueError, list,
@@ -1263,6 +1525,10 @@ class IpaddrUnitTest(unittest.TestCase):
                           self.ipv6_interface.network.subnets(-1))
         self.assertRaises(ValueError, list,
                           self.ipv6_network.subnets(-1))
+        self.assertRaises(ValueError, list,
+                          self.ipv6_scoped_interface.network.subnets(-1))
+        self.assertRaises(ValueError, list,
+                          self.ipv6_scoped_network.subnets(-1))
 
     def testGetNum_Addresses(self):
         self.assertEqual(self.ipv4_network.num_addresses, 256)
@@ -1275,6 +1541,11 @@ class IpaddrUnitTest(unittest.TestCase):
                          9223372036854775808)
         self.assertEqual(self.ipv6_network.supernet().num_addresses,
                          36893488147419103232)
+        self.assertEqual(self.ipv6_scoped_network.num_addresses, 18446744073709551616)
+        self.assertEqual(list(self.ipv6_scoped_network.subnets())[0].num_addresses,
+                         9223372036854775808)
+        self.assertEqual(self.ipv6_scoped_network.supernet().num_addresses,
+                         36893488147419103232)
 
     def testContains(self):
         self.assertIn(ipaddress.IPv4Interface('1.2.3.128/25'),
@@ -1296,6 +1567,9 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertEqual(str(self.ipv6_network[5]),
                          '2001:658:22a:cafe::5')
         self.assertRaises(IndexError, self.ipv6_network.__getitem__, 1 << 64)
+        self.assertEqual(str(self.ipv6_scoped_network[5]),
+                         '2001:658:22a:cafe::5')
+        self.assertRaises(IndexError, self.ipv6_scoped_network.__getitem__, 1 << 64)
 
     def testGetitem(self):
         # http://code.google.com/p/ipaddr-py/issues/detail?id=15
@@ -1315,6 +1589,8 @@ class IpaddrUnitTest(unittest.TestCase):
                          ipaddress.IPv4Interface('1.2.3.4/23'))
         self.assertFalse(self.ipv4_interface ==
                          ipaddress.IPv6Interface('::1.2.3.4/24'))
+        self.assertFalse(self.ipv4_interface ==
+                         ipaddress.IPv6Interface('::1.2.3.4%scope/24'))
         self.assertFalse(self.ipv4_interface == '')
         self.assertFalse(self.ipv4_interface == [])
         self.assertFalse(self.ipv4_interface == 2)
@@ -1329,6 +1605,20 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertFalse(self.ipv6_interface == [])
         self.assertFalse(self.ipv6_interface == 2)
 
+        self.assertTrue(self.ipv6_scoped_interface ==
+            ipaddress.IPv6Interface('2001:658:22a:cafe:200::1%scope/64'))
+        self.assertFalse(self.ipv6_scoped_interface ==
+            ipaddress.IPv6Interface('2001:658:22a:cafe:200::1%scope/63'))
+        self.assertFalse(self.ipv6_scoped_interface ==
+            ipaddress.IPv6Interface('2001:658:22a:cafe:200::1/64'))
+        self.assertFalse(self.ipv6_scoped_interface ==
+            ipaddress.IPv6Interface('2001:658:22a:cafe:200::1/63'))
+        self.assertFalse(self.ipv6_scoped_interface ==
+                         ipaddress.IPv4Interface('1.2.3.4/23'))
+        self.assertFalse(self.ipv6_scoped_interface == '')
+        self.assertFalse(self.ipv6_scoped_interface == [])
+        self.assertFalse(self.ipv6_scoped_interface == 2)
+
     def testNotEqual(self):
         self.assertFalse(self.ipv4_interface !=
                          ipaddress.IPv4Interface('1.2.3.4/24'))
@@ -1336,6 +1626,8 @@ class IpaddrUnitTest(unittest.TestCase):
                         ipaddress.IPv4Interface('1.2.3.4/23'))
         self.assertTrue(self.ipv4_interface !=
                         ipaddress.IPv6Interface('::1.2.3.4/24'))
+        self.assertTrue(self.ipv4_interface !=
+                        ipaddress.IPv6Interface('::1.2.3.4%scope/24'))
         self.assertTrue(self.ipv4_interface != '')
         self.assertTrue(self.ipv4_interface != [])
         self.assertTrue(self.ipv4_interface != 2)
@@ -1362,6 +1654,26 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertTrue(self.ipv6_address != [])
         self.assertTrue(self.ipv6_address != 2)
 
+        self.assertFalse(self.ipv6_scoped_interface !=
+            ipaddress.IPv6Interface('2001:658:22a:cafe:200::1%scope/64'))
+        self.assertTrue(self.ipv6_scoped_interface !=
+            ipaddress.IPv6Interface('2001:658:22a:cafe:200::1%scope/63'))
+        self.assertTrue(self.ipv6_scoped_interface !=
+            ipaddress.IPv6Interface('2001:658:22a:cafe:200::1/64'))
+        self.assertTrue(self.ipv6_scoped_interface !=
+            ipaddress.IPv6Interface('2001:658:22a:cafe:200::1/63'))
+        self.assertTrue(self.ipv6_scoped_interface !=
+                        ipaddress.IPv4Interface('1.2.3.4/23'))
+        self.assertTrue(self.ipv6_scoped_interface != '')
+        self.assertTrue(self.ipv6_scoped_interface != [])
+        self.assertTrue(self.ipv6_scoped_interface != 2)
+
+        self.assertTrue(self.ipv6_scoped_address !=
+                        ipaddress.IPv4Address('1.2.3.4'))
+        self.assertTrue(self.ipv6_scoped_address != '')
+        self.assertTrue(self.ipv6_scoped_address != [])
+        self.assertTrue(self.ipv6_scoped_address != 2)
+
     def testSlash32Constructor(self):
         self.assertEqual(str(ipaddress.IPv4Interface(
                     '1.2.3.4/255.255.255.255')), '1.2.3.4/32')
@@ -1369,6 +1681,8 @@ class IpaddrUnitTest(unittest.TestCase):
     def testSlash128Constructor(self):
         self.assertEqual(str(ipaddress.IPv6Interface('::1/128')),
                                   '::1/128')
+        self.assertEqual(str(ipaddress.IPv6Interface('::1%scope/128')),
+                                  '::1%scope/128')
 
     def testSlash0Constructor(self):
         self.assertEqual(str(ipaddress.IPv4Interface('1.2.3.4/0.0.0.0')),
@@ -1440,6 +1754,13 @@ class IpaddrUnitTest(unittest.TestCase):
         collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
         self.assertEqual(list(collapsed), [ip3])
 
+        ip1 = ipaddress.IPv6Network('2001::%scope/100')
+        ip2 = ipaddress.IPv6Network('2001::%scope/120')
+        ip3 = ipaddress.IPv6Network('2001::%scope/96')
+        # test that ipv6 addresses are subsumed properly.
+        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
+        self.assertEqual(list(collapsed), [ip3])
+
         # the toejam test
         addr_tuples = [
                 (ipaddress.ip_address('1.1.1.1'),
@@ -1453,6 +1774,18 @@ class IpaddrUnitTest(unittest.TestCase):
             self.assertRaises(TypeError, ipaddress.collapse_addresses,
                               [ip1, ip2])
 
+        addr_tuples = [
+                (ipaddress.ip_address('1.1.1.1'),
+                 ipaddress.ip_address('::1%scope')),
+                (ipaddress.IPv4Network('1.1.0.0/24'),
+                 ipaddress.IPv6Network('2001::%scope/120')),
+                (ipaddress.IPv4Network('1.1.0.0/32'),
+                 ipaddress.IPv6Network('2001::%scope/128')),
+        ]
+        for ip1, ip2 in addr_tuples:
+            self.assertRaises(TypeError, ipaddress.collapse_addresses,
+                              [ip1, ip2])
+
     def testSummarizing(self):
         #ip = ipaddress.ip_address
         #ipnet = ipaddress.ip_network
@@ -1472,6 +1805,8 @@ class IpaddrUnitTest(unittest.TestCase):
         # test that a summary over ip4 & ip6 fails
         self.assertRaises(TypeError, list,
                           summarize(ip1, ipaddress.IPv6Address('::1')))
+        self.assertRaises(TypeError, list,
+                          summarize(ip1, ipaddress.IPv6Address('::1%scope')))
         # test a /24 is summarized properly
         self.assertEqual(list(summarize(ip1, ip2))[0],
                          ipaddress.ip_network('1.1.1.0/24'))
@@ -1497,6 +1832,17 @@ class IpaddrUnitTest(unittest.TestCase):
                          [ipaddress.ip_network('1::/16'),
                           ipaddress.ip_network('2::/128')])
 
+        ip1 = ipaddress.ip_address('1::%scope')
+        ip2 = ipaddress.ip_address('1:ffff:ffff:ffff:ffff:ffff:ffff:ffff%scope')
+        # test an IPv6 is summarized properly
+        self.assertEqual(list(summarize(ip1, ip2))[0],
+                         ipaddress.ip_network('1::/16'))
+        # test an IPv6 range that isn't on a network byte boundary
+        ip2 = ipaddress.ip_address('2::%scope')
+        self.assertEqual(list(summarize(ip1, ip2)),
+                         [ipaddress.ip_network('1::/16'),
+                          ipaddress.ip_network('2::/128')])
+
         # test exception raised when first is greater than last
         self.assertRaises(ValueError, list,
                           summarize(ipaddress.ip_address('1.1.1.0'),
@@ -1522,6 +1868,10 @@ class IpaddrUnitTest(unittest.TestCase):
                         ipaddress.ip_address('::1'))
         self.assertTrue(ipaddress.ip_address('::1') <=
                         ipaddress.ip_address('::2'))
+        self.assertTrue(ipaddress.ip_address('::1%scope') <=
+                        ipaddress.ip_address('::1%scope'))
+        self.assertTrue(ipaddress.ip_address('::1%scope') <=
+                        ipaddress.ip_address('::2%scope'))
 
     def testInterfaceComparison(self):
         self.assertTrue(ipaddress.ip_interface('1.1.1.1/24') ==
@@ -1554,6 +1904,52 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertTrue(ipaddress.ip_interface('::1/64') >
                         ipaddress.ip_interface('::2/48'))
 
+        self.assertTrue(ipaddress.ip_interface('::1%scope/64') ==
+                        ipaddress.ip_interface('::1%scope/64'))
+        self.assertTrue(ipaddress.ip_interface('::1%scope/64') <
+                        ipaddress.ip_interface('::1%scope/80'))
+        self.assertTrue(ipaddress.ip_interface('::1%scope/64') <
+                        ipaddress.ip_interface('::2%scope/64'))
+        self.assertTrue(ipaddress.ip_interface('::2%scope/48') <
+                        ipaddress.ip_interface('::1%scope/64'))
+        self.assertTrue(ipaddress.ip_interface('::1%scope/80') >
+                        ipaddress.ip_interface('::1%scope/64'))
+        self.assertTrue(ipaddress.ip_interface('::2%scope/64') >
+                        ipaddress.ip_interface('::1%scope/64'))
+        self.assertTrue(ipaddress.ip_interface('::1%scope/64') >
+                        ipaddress.ip_interface('::2%scope/48'))
+
+
+        self.assertFalse(ipaddress.ip_interface('::1%scope/64') ==
+                        ipaddress.ip_interface('::1/64'))
+        self.assertTrue(ipaddress.ip_interface('::1%scope/64') <
+                        ipaddress.ip_interface('::1/80'))
+        self.assertTrue(ipaddress.ip_interface('::1%scope/64') <
+                        ipaddress.ip_interface('::2/64'))
+        self.assertTrue(ipaddress.ip_interface('::2%scope/48') <
+                        ipaddress.ip_interface('::1/64'))
+        self.assertTrue(ipaddress.ip_interface('::1%scope/80') >
+                        ipaddress.ip_interface('::1/64'))
+        self.assertTrue(ipaddress.ip_interface('::2%scope/64') >
+                        ipaddress.ip_interface('::1/64'))
+        self.assertTrue(ipaddress.ip_interface('::1%scope/64') >
+                        ipaddress.ip_interface('::2/48'))
+
+        self.assertFalse(ipaddress.ip_interface('::1/64') ==
+                        ipaddress.ip_interface('::1%scope/64'))
+        self.assertTrue(ipaddress.ip_interface('::1/64') <
+                        ipaddress.ip_interface('::1%scope/80'))
+        self.assertTrue(ipaddress.ip_interface('::1/64') <
+                        ipaddress.ip_interface('::2%scope/64'))
+        self.assertTrue(ipaddress.ip_interface('::2/48') <
+                        ipaddress.ip_interface('::1%scope/64'))
+        self.assertTrue(ipaddress.ip_interface('::1/80') >
+                        ipaddress.ip_interface('::1%scope/64'))
+        self.assertTrue(ipaddress.ip_interface('::2/64') >
+                        ipaddress.ip_interface('::1%scope/64'))
+        self.assertTrue(ipaddress.ip_interface('::1/64') >
+                        ipaddress.ip_interface('::2%scope/48'))
+
     def testNetworkComparison(self):
         # ip1 and ip2 have the same network address
         ip1 = ipaddress.IPv4Network('1.1.1.0/24')
@@ -1633,6 +2029,7 @@ class IpaddrUnitTest(unittest.TestCase):
                         ipaddress.ip_network('1.1.1.2'))
         self.assertFalse(ipaddress.ip_network('1.1.1.2') <=
                         ipaddress.ip_network('1.1.1.1'))
+
         self.assertTrue(ipaddress.ip_network('::1') <=
                         ipaddress.ip_network('::1'))
         self.assertTrue(ipaddress.ip_network('::1') <=
@@ -1643,6 +2040,7 @@ class IpaddrUnitTest(unittest.TestCase):
     def testStrictNetworks(self):
         self.assertRaises(ValueError, ipaddress.ip_network, '192.168.1.1/24')
         self.assertRaises(ValueError, ipaddress.ip_network, '::1/120')
+        self.assertRaises(ValueError, ipaddress.ip_network, '::1%scope/120')
 
     def testOverlaps(self):
         other = ipaddress.IPv4Network('1.2.3.0/30')
@@ -1671,13 +2069,28 @@ class IpaddrUnitTest(unittest.TestCase):
         self.assertEqual(ipaddress.ip_address('FFFF::192.0.2.1'),
                           ipaddress.ip_address('FFFF::c000:201'))
 
+        self.assertEqual(ipaddress.ip_address('::FFFF:192.0.2.1%scope'),
+                          ipaddress.ip_address('::FFFF:c000:201%scope'))
+        self.assertEqual(ipaddress.ip_address('FFFF::192.0.2.1%scope'),
+                          ipaddress.ip_address('FFFF::c000:201%scope'))
+        self.assertNotEqual(ipaddress.ip_address('::FFFF:192.0.2.1%scope'),
+                            ipaddress.ip_address('::FFFF:c000:201'))
+        self.assertNotEqual(ipaddress.ip_address('FFFF::192.0.2.1%scope'),
+                            ipaddress.ip_address('FFFF::c000:201'))
+        self.assertNotEqual(ipaddress.ip_address('::FFFF:192.0.2.1'),
+                          ipaddress.ip_address('::FFFF:c000:201%scope'))
+        self.assertNotEqual(ipaddress.ip_address('FFFF::192.0.2.1'),
+                          ipaddress.ip_address('FFFF::c000:201%scope'))
+
     def testIPVersion(self):
         self.assertEqual(self.ipv4_address.version, 4)
         self.assertEqual(self.ipv6_address.version, 6)
+        self.assertEqual(self.ipv6_scoped_address.version, 6)
 
     def testMaxPrefixLength(self):
         self.assertEqual(self.ipv4_interface.max_prefixlen, 32)
         self.assertEqual(self.ipv6_interface.max_prefixlen, 128)
+        self.assertEqual(self.ipv6_scoped_interface.max_prefixlen, 128)
 
     def testPacked(self):
         self.assertEqual(self.ipv4_address.packed,
@@ -1692,6 +2105,14 @@ class IpaddrUnitTest(unittest.TestCase):
                             + b'\x00' * 6)
         self.assertEqual(ipaddress.IPv6Interface('::1:0:0:0:0').packed,
                          b'\x00' * 6 + b'\x00\x01' + b'\x00' * 8)
+        self.assertEqual(self.ipv6_scoped_address.packed,
+                         b'\x20\x01\x06\x58\x02\x2a\xca\xfe'
+                         b'\x02\x00\x00\x00\x00\x00\x00\x01')
+        self.assertEqual(ipaddress.IPv6Interface('ffff:2:3:4:ffff::%scope').packed,
+                         b'\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff'
+                            + b'\x00' * 6)
+        self.assertEqual(ipaddress.IPv6Interface('::1:0:0:0:0%scope').packed,
+                         b'\x00' * 6 + b'\x00\x01' + b'\x00' * 8)
 
     def testIpType(self):
         ipv4net = ipaddress.ip_network('1.2.3.4')
--- /dev/null
+++ python3.8-3.8.10/Misc/NEWS.d/next/Library/2019-07-17-08-26-14.bpo-34788.pwV1OK.rst
@@ -0,0 +1,2 @@
+Add support for scoped IPv6 addresses to :mod:`ipaddress`. Patch by Oleksandr 
+Pavliuk.
